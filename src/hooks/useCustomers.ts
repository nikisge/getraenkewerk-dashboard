import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { Tables, TablesInsert } from "@/integrations/supabase/types";

export type Customer = Tables<"dim_customers">;

export interface CustomerFilters {
  searchTerm?: string;
  repId?: number | null;
  statusActive?: boolean | null;
  abcClass?: string | null;
  incompleteOnly?: boolean;
}

export interface PaginationParams {
  page: number;
  pageSize: number;
}

export interface CustomersResult {
  customers: Customer[];
  totalCount: number;
  totalPages: number;
}

export function useCustomers(
  filters: CustomerFilters = {},
  pagination: PaginationParams = { page: 0, pageSize: 50 }
) {
  return useQuery({
    queryKey: ["customers", filters, pagination],
    queryFn: async (): Promise<CustomersResult> => {
      const { searchTerm, repId, statusActive, abcClass, incompleteOnly } = filters;
      const { page, pageSize } = pagination;
      const from = page * pageSize;
      const to = from + pageSize - 1;

      // Single query with count - much faster!
      let query = supabase
        .from("dim_customers")
        .select("kunden_nummer, firma, email, ort, plz, strasse, telefon, mobil, u_key, rep_id, purchase_interval, season_start, season_end, status_active, abc_class, revenue_365d", { count: "exact" })
        .order("firma")
        .range(from, to);

      // Apply filters
      if (searchTerm?.trim()) {
        query = query.ilike("firma", `%${searchTerm.trim()}%`);
      }
      if (repId !== undefined && repId !== null) {
        query = query.eq("rep_id", repId);
      }
      if (statusActive !== undefined && statusActive !== null) {
        query = query.eq("status_active", statusActive);
      }
      if (abcClass) {
        query = query.eq("abc_class", abcClass);
      }
      // Filter for incomplete (auto-generated) customers
      // These have u_key starting with 'auto_' or 'AUTOGENERATED|' prefix
      if (incompleteOnly) {
        query = query.or("u_key.ilike.auto_%,u_key.ilike.AUTOGENERATED|%");
      }

      const { data, count, error } = await query;
      if (error) throw error;

      return {
        customers: data as Customer[],
        totalCount: count || 0,
        totalPages: Math.ceil((count || 0) / pageSize),
      };
    },
    staleTime: 30000, // Cache for 30 seconds
    gcTime: 60000, // Keep in cache for 1 minute
  });
}

export function useUpdateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      kunden_nummer,
      updates
    }: {
      kunden_nummer: number;
      updates: Partial<Customer>
    }) => {
      const { data, error } = await supabase
        .from("dim_customers")
        .update(updates)
        .eq("kunden_nummer", kunden_nummer)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["customers"] });
    },
  });
}

export function useCreateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (customer: TablesInsert<"dim_customers">) => {
      const { data, error } = await supabase
        .from("dim_customers")
        .insert(customer)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["customers"] });
    },
  });
}
